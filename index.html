<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="it" lang="it">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Perch&eacute; Git &egrave; Meglio di X</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection" />
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print" />
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js" type="text/javascript"></script>
	
	<style type="text/css">
		html { overflow-y: scroll; }
		body { margin-top: 1.5em; }
		.header h1 { font-size: 3.2em; color: #666; }
		.expand_collapse_links { text-align: center; margin-bottom: 1.5em; }
		.expand_collapse_links a { color: #555; }
		img { margin-bottom: 10px; }
		.center { text-align: center; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
    .section h2 a { color: #333; text-decoration:none; display: block; }
		.section { padding-bottom: 2px; }
		.contents { padding: 0 10px; width: 610px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.nowrap { white-space: nowrap; }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; } 
		.lang a {color: inherit; text-decoration: none;}
	</style>
	
</head>

<body>
  <!-- TODO: all images need alt tags for valid XHTML 1.0 Strict -->

	<div class="container">

	    <div class="span-24 header">
				<table width="100%">
					<tr><td>
        		<h1>Perch&eacute; Git &egrave; Meglio di X</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg"><a href="#hg">hg</a></span>
							<span class="lang bzr"><a href="#bzr">bzr</a></span>
							<span class="lang svn"><a href="#svn">svn</a></span>
							<span class="lang perforce"><a href="#perforce">perforce</a></span>
						</div>
						<img style="float: right" alt="where &quot;x&quot; is one of" src="images/wherex.gif" />
					</td></tr>
					</table>
	    </div>

	    <div class="span-24">
					<div class="text intro">
						Questo sito esiste perché ultimamente sembra che io dia l'impressione 
						di stare molto tempo a difendere gli utilizzatori di Git da accuse di fanatismo 
						acritico, di cavalcare l'onda di quel che sembra promettente e di voler 
						essere creduti a prescindere dai fatti.
						Così, ecco qua il perché  le persone stanno passando da X a Git e le motivazioni 
						per cui dovresti farlo anche tu. Basta semplicemente cliccare su una motivazione per vederla.
					</div>
					
					<div class="expand_collapse_links" style="display: none;">
					  <a href="#" class="expand_all">Espandi tutto</a> |
					  <a href="#" class="collapse_all">Riduci tutto</a>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="cheap-local-branching" href="#cheap-local-branching">Branching Locale Senza Sforzi</a>
	        </h2>
					<div class="contents">
						
						<div class="text">
							Probabilmente la caratteristica più attraente di Git, che lo posiziona davvero
							in una categoria a parte rispetto a praticamente ogni altro SCM esistente, è il suo
							modello di branching.  È completamente differente rispetto a tutti gli altri modelli 
 							con cui verrà confrontato qui, molti dei quali sostengono l'idea che il branching migliore
 							sia fondamentalmente un clone del repository in una nuova directory.
						</div>
						
						<div class="text">
						  Git non funziona in tal modo. Git consente di avere parecchie branch locali che 
						  possono essere completamente indipendenti l'una dall'altra consentendo peraltro
						  la creazione, merging e cancellazione di linee di sviluppo secondarie.
						</div>
						
						
						<div class="text">
							Questo vuol dire che tu puoi fare cose come:
							<ul>
								<li>Creare una branch per provare un'idea, fare qualche commit, tornare indietro 
								al punto dal quale hai fatto il branching, applicare una patch, riprendere al
								punto in cui stavi facendo gli esperimenti per poi farne un merge.
								</li>
								<li>Avere una branch che contiente sempre e solo quello che va in produzione,
								  un'altra dentro cui fai il merge per il testing e parecchie branch più
								  piccole per il tuo lavoro quotidiano ordinario.
								</li>
								<li>Creare nuove branch per ciascuna singola funzionalità alla quale stai lavorando,
									in modo da poter alternarti senza interruzioni su ciascuna di esse, ed eliminare gradualmente
									ciascuna branch per la quale la funzionalità venga incorporata nella branch principale.
								</li>
								<li>Creare una branch e sperimentarci dentro, per poi renderti conto che non funzionerà
									e cancellarla senza problemi, abbandonando il lavoro &mdash; senza che nessun altro neppure
									lo veda (anche nel caso in cui nel frattempo hai eseguito push su altre branch).
								</li>
							</ul>
						</div>
						
						<img src="images/branches.png" alt="branches flowchart"/>
						
						<div class="text">
							Nota che quando esegui un push su un repository remoto, <em>non</em> ti viene richiesto di
							inviare tutte le tue branch. Puoi condividerne qualcuna o nessuna di esse. Questo consente di
							lasciare libere le persone di provare nuove idee senza la preoccupazione di dover pianificare 
							come e quando dovranno effettuarne il merging o come condividerle con gli altri.
						</div>
						
						<div class="text">
							È <em>possibile</em> riuscire a fare alcune di queste cose con gli altri sistemi, ma 
							il lavoro necessario è molto più arduo e predisposto ad errori. Git lo rende invece
							incredibilmente semplice e, non appena assimilato, cambia il modo di lavorare di molti sviluppatori.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif" />
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif" />
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif" />
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif" />
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif" />
						</div>
					</div>
	    </div>
				
	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
	        <h2>
          <a name="everything-is-local" href="#everything-is-local">Tutto è Locale</a>
	        </h2>
					<div class="contents">	

						<div class="text">
							Ciò è fondamentalmente vero per tutti i SCM distribuiti, ma
							dalla mia esperienza lo è ancor di più con Git. Ci sono veramente
							poche occorrenze di 'fetch', 'pull', 'push' che non comunichino 
							con qualcosa di diverso del tuo hard disk.
						</div>

						<div class="text">
							Ciò non soltanto rende molte delle operazioni molto più veloci
							di quanto non lo siano abitualmente, ma ti consente inoltre di 
							lavorare alle tue cose offline.
							Anche se potrebbe non sembrare una grande cosa, vengo ogni volta
							meravigliato da quanto spesso io lavori offline. Essere in grado di 
							creare branch, eseguire merge, commit e navigare la storia del 
							progetto mentre si è in aereo o in treno è davvero produttivo.
						</div>
						
						<div class="center"><img width="500px" src="images/local-remote.png" alt="local repo to remote repo flowchart" /></div>

						<div class="text">
							Anche in Mercurial, comandi comuni come 'incoming' e 'outgoing' 
							scomodano il server, mentre invece con Git puoi fare 'fetch' da
							tutti i server prima di andare offline e fare confronti, eseguire
							un merge e loggare i dati che sono sul server ma non ancora sulle
							tue branch locali.
						</div>
												
						<div class="text">
							Questo vuol dire che è proprio facile avere copie non solo delle 
							tue branch, ma anche di tutte quelle di coloro i quali stanno 
							lavorando con te nel tuo repository senza dover creare disordine 
							tra le tue cose.
						</div>
						
					</div>
	    </div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
	        <h2>
          <a name="git-is-fast" href="#git-is-fast">Git è Veloce</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							Git è veloce. Tutti &mdash; anche i più fedeli utenti degli altri sistemi &mdash; 
							generalmente riconoscono a Git tale titolo. Con Git, tutte le operazioni sono eseguite localmente,
							concedendo un pò di vantaggio a SVN e Perforce, entrambe le quali richiedono accesso alla rete per
							alcune operazioni. Comunque, anche se confrontato con altri DSCMs che effettuano operazioni
							localmente, Git è bello veloce.
						</div>
					
						<div class="text">
							Parte di questo è possibilmente dovuto al fotto che è stato costruito per lavorare sul 
							kernel di Linux, il che significa che ha dovuto affrontare in modo efficiente un grosso 
							repository sin dal primo giorno. Inoltre, Git è scritto in C e riduce l'overhead dei 
							runtime tipici dei linguaggi di più alto livello.
							Un altro motico per cui Git è veloce è che gli sviluppatori principali hanno fatto
							della velocità un obiettivo progettuale dell'applicazione.
						</div>

						<div class="text">
							In seguito ci sono i valori di benchmark che ho eseguito su tre copie
							del repository contentente il codice sorgente di Django in 3 diversi SCM:
							Git, Mercurial and Bazaar.  Ho anche eseguito test di questa cosa in SVN,
							ma credimi, è più lento - praticamente puoi prendere i valori di Bazaar e
							aggiungere la latenza di rete....
						</div>

            <table>  
						<tr><td class="nowrap">
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:2,5,60&amp;chds=0,60&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Init" alt="init benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:85,3,23&amp;chds=0,100&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Add" alt="add benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:45,194,1474&amp;chds=0,1474&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Status" alt="status benchmarks" />
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,21,142&amp;chds=0,142&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Diff" alt="diff benchmarks" />
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&amp;chs=190x275&amp;chd=t:1,123,390|11,946,820&amp;chds=0,1210&amp;chxt=x&amp;chco=4d89f9,c6d9fd&amp;chl=git|hg|bzr&amp;chtt=Branching" alt="branching benchmarks" />
						</td></tr>
            <tr><td class="nowrap">
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,120,189&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Tag" alt="tag benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:7,26,90&amp;chds=0,90&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Log" alt="log benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:124,125,230&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit (Lg)" alt="large commit benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:8,51,113&amp;chds=0,113&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit (Sm)" alt="small commit benchmarks" />
						</td></tr>
						</table>
						
						<div class="text">
							Il risultato finale è stato quello che in tutto, tranne che 
							nell'aggiunta di nuovi file, Git è risultato il più veloce.
							(Anche per grandi operazioni di commit, che Hg praticamente 
							eguagliava, ma considera che il commit provato era così grande
							che difficilmente sarà mai fatto in applicazioni reali qualcosa 
							del genere - le comuni operazioni di commit sono molto più veloci 
							in Git)
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Init</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Add</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Tag</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Commit (Grande)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Commit (Piccolo)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Branch (A freddo)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Branch (A caldo)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
							I dati di branch a freddo e a caldo sono relativi a quei test provati 
							la prima e la seconda volta creando una branch su un repository - essendo il 
							secondo valore una branch con una cache disco ancora "calda".
						</div>

						<div class="text">
							Sarebbe da notare che sebbene i dati per 'add' sono molto più lenti,
							questo vale per inserimenti di numerosi file - più di 2000. Per la gran parte
							di quello che la maggioranza delle persone fa quotidianamente, operazioni
							di 'add' impiegano soltanto una frazione di secondo in ciascuno di tali sistemi 
							Tutte le altre operazioni testate qui (eccezion fatta per grandi commit, forse)
							sono maggiormente indicative sulle cose che potresti effettivamente fare giorno
							per giorno.
						</div>
					
					
					<div class="text">
						Questi valori non sono molto difficili da riprodurre, basta semplicemente clonare il progetto
						Django in ciascuno dei sistemi e provare alcuni comandi in ciascuno.
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
	    </div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
	        <h2>
          <a name="git-is-small" href="#git-is-small">Git è Compatto</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
							Git è proprio bravo a limitare l'occupazione del disco. La tua directory Git
							sarà (in generale) appena più larga di un checkout con SVN &mdash; in alcuni
							casi proprio più piccola (pare che ci finisca un bel pò di roba in quelle 
							directory .svn).
						</div>
					
						<div class="text">
							I seguenti dati sono presi da cloni del progetto Django in ciascun dei suoi 
							mirror Git semi-ufficiali allo stesso punto della history.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>Bzr*</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Repo Singolo</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td>89M</td>
								<td></td>
							</tr>
							<tr>
								<td>Intera Directory</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td>108M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
						<div class="text"><small>
							* il secondo dato Bzr è stato ottenuto dopo che ho lanciato 'bzr pack', che
							pansavo dovesse servire a compattarlo, ma invece è finito, 
							per qualche ragione, col renderlo molto più grosso.
						</small></div>
						
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
	        <h2>
          <a name="the-staging-area" href="#the-staging-area">L'Area di Stage</a>
	        </h2>
					<div class="contents">
						<div class="text">
							A differenza degli altri sistemi, Git ha quel che si chiama un'"area di stage"
							o "indice".  È un'area intermedia nella quale puoi impostare come deve presentarsi
							quello che intendi mandare in commit prima di eseguirlo.
						</div>
						<div class="text">
							Il bello dell'area di stage e che posiziona Git a parte rispetto agli altri
							strumenti, è che in un modo semplice si possono porre in stage solo alcuni dei tuoi 
							files man mano che li hai pronti ed effettuare il commit su di loro e non su 
							su tutti i file modificati, o anche elencarli dalla linea di comando durante il commit.
						</div>
						<div class="center"><img src="images/index1.png" alt="add commit workflow diagram" /></div>
						
						<div class="text">
						  Questa cosa ti consente di mettere in stage solo porzioni di un file modificato.
						  Sono finiti i tempi in cui dovevi fare due modifiche logicamente distinte su un file 
						  prima che ti rendessi conto di esserti dimenticato di fare il commit su una delle due.
						  Adesso puoi mettere in stage la modifica di cui hai bisogno per il commit attuale e 
						  in seguito mettere in stage le altre per il commit successivo. Questa caratteristica 
						  funziona per un qualsiasi numero di modifiche del file che ti servano.
						</div>

						<div class="text">
							Naturalmente, Git ti lascia ignorare le suddette caratteristiche se non hai bisogno
							di un tale tipo di controllo  &mdash; basta spiattellare un '-a' al tuo comando di
							commit per aggiungere tutti i cambiamenti a tutti i file nell'area di stage.
						</div>
						
						<div class="center"><img src="images/index2.png" alt="commit only workflow diagram" /></div>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="distributed" href="#distributed">Distribuito</a>
	        </h2>

					<div class="contents">

					  <div class="text">
               Ona delle cose più forti di un SCM distribuito, incluso Git, è quello di essere distribuito.
               Questo significa che invece di fare un "checkout" dell'attuale punta del codice sorgente, fai 
               un "clone" dell'intero repository.
            </div>
            <div class="text">
               Questo vuol dire che anche se stai usando un workflow centralizzato, ogni utente ha quel che è
               essenzialmente un backup del server centrale, da ciascuno del quale potrebbe essere lanciato un
               push per rimpiazzare il server principale nel caso di un crash o corruzione di file. Praticamente
               non c'è un Single Point of Failure con Git a meno che ci sia un solo punto.
            </div>

            <div class="text">
               E questo senza neppure rallentare l'operatività. In media, un checkout SVN è solo marginalmente più 
               veloce di quasiasi altro DSCM. Tra i DSCM testati, Git è risultato il più veloce.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=200x150&amp;chd=t:120,144,311,64&amp;chds=0,320&amp;chco=4d89f9&amp;chl=git|hg|bzr|svn&amp;chtt=Clone" alt="cloning benchmarks" />
							</td><td style="width: 80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
       	<h2>
        <a name="any-workflow" href="#any-workflow">Qualsiasi Workflow</a>
       	</h2>

				<div class="contents">
					
					<div class="text">
						Una delle cose affascinanti di Git è che grazie alla sua natura distribuita
						ed al suo superbo sistema di branching, si può implementare, in modo relativamente
						semplice, qualunque workflow immmaginabile.
					</div>
					
					<h3>Workflow in stile Subversion</h3>
					

					<div class="text">
						Un workflow Git molto comune, specialmente per le persone che 
						provengono da un sistema centralizzato, è, per l'appunto, un workflow
						centralizzato.
						Git non ti consentirà di eseguire un push se qualcuno ha effettuato
						un push dall'ultima volta che hai lanciato un fetch, in modo che il
						modello centralizzato in cui tutti gli sviluppatori eseguono push
						sullo stesso server funziona proprio bene.
					</div>
					
					<div class="center"><img src="images/workflow-a.png" alt="subversion-style workflow" /></div><br/>
					
					<h3>Workflow Integration Manager</h3>

					<div class="text">
					  Un altro workflow comune in Git è dove c'è un integration manager
						&mdash; una sola persona che esegue commit sul repository 'prescelto',
						e poi un gruppo di sviluppatori che clonano da tale repository, fanno
						un push verso i propri repository indipendenti e chiedono all'integrator
						di inserire le proprie modifiche. Questo è il modello di sviluppo che
						si vede spesso nell'open source o nei repository di GitHub.
					</div>

					<div class="center"><img src="images/workflow-b.png" alt="integration manager workflow" /></div><br/>

					<h3>Dictator and Lieutenants Workflow</h3>

					<div class="text">
						Per progetti imponenti, si possono disporre gli sviluppatori in un modo
						simile al modo in cui ciò avviene per il kernel di Linux, dove le persone
						che sono responsabili di un certo sottosistema del progetto ('luogotententi')
						ed eseguono il merging di tutti i cambiamenti che sono pertinenti con tale 
						sottosistema. In seguito un altro integratore di sistema (il 'dittatore')
						può prelevare i cambiamenti dai propri luogotenenti ed effettuare un push
						al repository 'prescelto' dal quale tutti clonano in seguito.
					</div>

					<div class="center"><img src="images/workflow-c.png" alt="dictator and lieutenants workflow" /></div><br/>
					
					<div class="text">
						Lo ribadisco, Git è completamente flessibile su questa cosa, per cui puoi
						selezionare, combinare e scegliere il workflow che ritieni adatto a te.
          </div>
					
				</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang bzr">bzr</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

        <h2>
        <a name="github" href="#github">GitHub</a>
        </h2>
				
				<div class="contents">

          <img style="float:right; padding:10px" src="images/octocat.png" alt="octocat" />

					<div class="text">
						<em>Potrei</em> essere di parte qui, dal momento che lavoro per
						<a href="http://github.com">GitHub</a>, ma aggiungo questa sezione 
						comunque perché ci sono talmente tante persone a dire che è stato 
						GitHub stesso il motivo specifico per cui hanno scelto Git.
					</div>

					<div class="text">					
						Per molta gente GitHub è una ragione per usare Git perché si avvicina più
						ad un social network per il codice che ad un semplice sito di hosting.
						Le persone trovano altri sviluppatori o progetti che sono simili alle cose che
						stanno facendo e possono fare un fork e contribuire con facilità, creando così
						una community piena di energia ed entusiasmo attorno a Git ed ai progetti per cui
						la gente lo usa.
					</div>
					
					<div class="text">					
						Ci sono altri servizi, sia per Git che per gli altri SCM, ma pochi sono 
						orientati all'utente o hanno un obiettivo sociale e nessuno di loro si 
						avvicina alla base di utenza.
						L'aspetto sociale di GitHub è l'arma vincente, e questo combinato con
						le funzionalità sopra elencate rendono il lavoro con Git e GitHub una 
						grande combinazione per sviluppare rapidamente progetti open source.
					</div>

					<div class="text">					
            Questo tipo di community non la trovi per nessun altro tipo di SCM.
          </div>
					
					<div class="tweets">
						<img alt='puls twitter' width="300" src="http://twictur.es/i/1022858126.gif" />
						<img alt='twitter' width="300" src="http://twictur.es/i/1022857633.gif" />
					</div>
				</div>
	    </div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
        <h2>
        <a name="easy-to-learn" href="#easy-to-learn">Facile da Imparare</a>
        </h2>
        
				<div class="contents">
					<div class="text">										
						Questo non era proprio vero &mdash; all'inizio della vita di Git, quando non era un 
						vero e proprio SCM ma piuttosto un mucchio di strumenti che consentivano di avere 
						un lavoro in modo distribuito. Comunque, oggi, il set di comandi e la curva di apprendimento 
						di Git sono pressoché le stesse di un qualsiasi altro SCM, e anche meglio.
					</div>

					<div class="text">										
						Dal momento che questo è difficile da dimostrare in modo obiettivo senza un qualche tipo di
						studio, mostrerò le differenze tra il menu di help predefinito per i comandi Mercurial e Git.
						Ho sottolineato i comandi che sono identici (o quasi) tra i due sistemi. (In Hg, se scrivi 
						'hg help', ti ritrovi una lista di una 40-ina di comandi).
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Mercurial Help</h3>
<pre>
<span class="compare">add</span>        add the specified files ...
<span class="compare">annotate</span>   show changeset informati...
<span class="compare">clone</span>      make a copy of an existi...
<span class="compare">commit</span>     commit the specified fil...
<span class="compare">diff</span>       diff repository (or sele...
export     dump the header and diff...
<span class="compare">init</span>       create a new repository ...
<span class="compare">log</span>        show revision history of...
<span class="compare">merge</span>      merge working directory ...
parents    show the parents of the ...
<span class="compare">pull</span>       pull changes from the sp...
<span class="compare">push</span>       push changes to the spec...
<span class="compare">remove</span>     remove the specified fil...
serve      export the repository vi...
<span class="compare">status</span>     show changed files in th...
update     update working directory
</pre>

					</td><td valign="top">
						
<h3>Git Help</h3>
<pre>
<span class="compare">add</span>        Add file contents to the index
<span class="compare">bisect</span>     Find the change that introduce...
<span class="compare">branch</span>     List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>      Clone a repository into a new ...
<span class="compare">commit</span>     Record changes to the repository
<span class="compare">diff</span>       Show changes between commits, ...
fetch      Download objects and refs from...
grep       Print lines matching a pattern
<span class="compare">init</span>       Create an empty git repository
<span class="compare">log</span>        Show commit logs
<span class="compare">merge</span>      Join two or more development h...
mv         Move or rename a file, a direc...
<span class="compare">pull</span>       Fetch from and merge with anot...
<span class="compare">push</span>       Update remote refs along with ...
rebase     Forward-port local commits to ...
reset      Reset current HEAD to the spec...
<span class="compare">rm</span>         Remove files from the working ...
show       Show various types of objects
<span class="compare">status</span>     Show the working tree status
<span class="compare">tag</span>        Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">										
					Prima di Git 1.6, tutti i comandi Git solevano stare nel path dei file 
					eseguibili, cosa che risultava veramente confusionaria per le persone.
					Sebbene Git li riconosce ancora tutti, l'unico comando nel path è adesso
					'git'.
					Per cui, se guardi Mercurial e Git, Git ha praticamente un set di comandi 
					ed un sistema di help identico &mdash;al giorno d'oggi c'è veramente poca 
					differenza mettendosi nella prospettiva dell'interfaccia utente.
				</div>
				
				<div class="text">										
					Al giorno d'oggi è proprio difficile sostenere che Mercurial o Bazaar
					siano più semplici da imparare di Git.
				</div>
				
				</div>
				
	    </div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

    <div class="span-24">					
				<div class="expand_collapse_links" style="display: none;">
				  <a href="#" class="expand_all">Espandi tutto</a> |
				  <a href="#" class="collapse_all">Riduci tutto</a>
				</div>
    </div>
    
    <div class="span-24 footer">
			Questo sito è mantenuto da <a href="http://github.com/schacon">Scott Chacon</a>, un <a href="http://github.com">GitHubber</a>.<br/>
			Se sei in disaccordo con qualsiasi cosa detta sul sito ed hai una buona ragione,  
			<a href="mailto:michelangelo@altamore.org?subject=[Perché Git è Migliore di X]">scrivimi</a> per favore, in modo che io possa sistemarla.<br/>
			Il sorgente di questo sito è <a href="http://github.com/michelangeloaltamore/whygitisbetter">su GitHub</a> - 
			non esitare a inviare patch se vuoi contribuire a migliorarlo.<br/>
			<a href="http://validator.w3.org/check?uri=referer">Valid XHTML</a>
		</div>

	</div>

  <script type="text/javascript">
    $(function() {
      $('.section .contents').hide()
      $('.contents .tweets').hide()

      $('.expand_collapse_links').show()
      $('.expand_collapse_links .expand_all').click(function() {
        $('.section .contents').show()
      })
      $('.expand_collapse_links .collapse_all').click(function() {
        $('.section .contents').hide()
      })

      $('.section h2').click(function() {
        var hidden = $(this).next().is(':hidden')
        $(this).next().slideToggle()
        return hidden
      })

      $('#menu span').css('cursor', 'pointer').find('a').click(function() {
        $('.section .contents').hide();
        $('.section .' + this.innerHTML).parents('.section').find('.contents').show();
      }) 

      if (document.location.hash) {
        $('.section > h2 > a[name=' + document.location.hash.substring(1) + ']').parent('h2').click();
        $('.section .' + document.location.hash.substring(1)).parents('.section').find('.contents').show();
      }    
    })

  </script>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>

